{ ---------------------------------------------------------------------	}
{ В данном файле находятся используемые при наладке модуля, а именно:	}
{ - проверка работоспособности линии INT внешнего прерывания (DSP IRQ0);}
{ - управление двухцветным светодиодом на выходных ТТЛ линиях DO0 и DO1	}
{ ---------------------------------------------------------------------	}

.ENTRY Irq0Handler;

{ *********************************************************************	}
{ команда перевода модуля в наладочный режим										}
{ *********************************************************************	}
Nakadka_Mode_cmd:
	GetPm(AR, NaladkaTestNumberAddr);{ считаем номер наладочного теста	}
	AR = PASS AR;
	IF EQ JUMP EmptyTest;       			{ тест номер 0	- пустой				}
	AR = AR-0x1;
	IF EQ JUMP ExternalInterruptsTest;	{ тест номер 1	- внеш. прерывания}
	AR = AR-0x1;
	IF EQ JUMP BiColorLedTest; 			{ тест номер 2	- светодиод			}
	

{ ошибочный номер наладочного теста													}	
	JUMP ErrorEndOfCommand;

{ =====================================================================	}
{ *********************************************************************	}
{ пустой наладочный режим																}
{ *********************************************************************	}
EmptyTest:
{ временно запретим все прерывания													}
	DIS INTS;

{ восстановим прерывания																}
	GetPm(AR,ImaskValueAddr);
	AR= CLRBIT 1 OF AR;				{ запретим прерывания IRQ0(внеш.линия)	}
	PutPm(AR,ImaskValueAddr);
	IMASK = AR; NOP;

{ очистим запросы на прерывание IRQ0 (внеш.линия)								}
	IFC = 0x02; NOP;

{ разрешим все размаскированные прерывания										}
	ENA INTS;

{ Функция управления состояниями цифровых выходных линий						}
	CALL Put_TTL;
{ установим требуемое состояние доступности TTL выходов						}
	CALL Enable_TTL_Out;
{ по месту метки MainLoop пропишем код CALL PutAcdData						}
	I4 = ^MainLoop; AR = ^PutAcdData; CALL ModifyCall;

{ штатное завершение выполнения команды											}
	JUMP EndOfCommand;
{ =====================================================================	}



{ =====================================================================	}
{ *********************************************************************	}
{ наладочный режим для проверки работоспособности линии INT					}
{ внешнего прерывания (DSP IRQ0)														}
{ *********************************************************************	}
ExternalInterruptsTest:
{ временно запретим все прерывания													}
	DIS INTS;

{ сбросим счетчик прерываний IRQ0													}
	AR = 0x00; PutPm(AR, NaladkaIrq0CounterAddr);

{ разрешим прерывания IRQ0																}
	GetPm(AR,ImaskValueAddr);
	AR= SETBIT 1 OF AR;				{ разрешим прерывания IRQ0(внеш.линия)	}
	PutPm(AR,ImaskValueAddr);
	IMASK = AR; NOP;

{ очистим запросы на прерывание IRQ0 (внеш.линия)								}
	IFC = 0x02; NOP;

{ разрешим все размаскированные прерывания										}
	ENA INTS;

{ штатное завершение выполнения команды											}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ Обработчик прерываний IRQ0															}
{ *********************************************************************	}
Irq0Handler:
{ сохраним регистр I4																	}
	AY0 = I4;

{ инкрементируем счетчик прерываний IRQ0											}
	GetPm(AR,NaladkaIrq0CounterAddr); 
	AR = AR + 0x1; 
	PutPm(AR,NaladkaIrq0CounterAddr);

{ восстановим регистр I4																}
	I4 = AY0;

{ выходим из обработчика прерываний													}
	RTI;
{ =====================================================================	}



{ =====================================================================	}
{ *********************************************************************	}
{ наладочный режим для управления двухцветным светодиодом, который		}
{ подсоединён к двум выходным ТТЛ линиям: DO0 и DO1 							}
{ *********************************************************************	}
BiColorLedTest:
{ выводим TTL OUT из третьего состояния											}
	AR = DM(Prog_Flag_Data); AR = CLRBIT 0 OF AR; DM(Prog_Flag_Data) = AR;	

{ по месту метки MainLoop пропишем код CALL LedControl						}
	I4 = ^MainLoop; AR = ^LedControl; CALL ModifyCall;

{ штатное завершение выполнения команды											}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ функция управления двухцветным светодиодом, который подсоединён			}
{ к двум выходным ТТЛ линиям: DO0 и DO1 											}
{ *********************************************************************	}
LedControl:
	AR = 0x0; IO(TTL_OUT) = AR;
	AR = 100; CALL DalayMlsAndCommandProcessing;

	AR = 0x1; IO(TTL_OUT) = AR;
	AR = 100; CALL DalayMlsAndCommandProcessing;

	AR = 0x3; IO(TTL_OUT) = AR;
	AR = 100; CALL DalayMlsAndCommandProcessing;

	AR = 0x2; IO(TTL_OUT) = AR;
	AR = 100; CALL DalayMlsAndCommandProcessing;

{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ 																								}
{ *********************************************************************	}
DalayMlsAndCommandProcessing:
	CNTR = AR;	
	DO DalayLoop UNTIL CE;
		AR = 1; CALL DelayMls;
		CALL CommandProcessing;
DalayLoop: NOP;

{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ задержка в единицах млс																}
{ *********************************************************************	}
DelayMls:
	CNTR = 1000;
	DO Lab1 UNTIL CE;
		CNTR = 48;
		DO Lab2 UNTIL CE;
	Lab2: NOP;
Lab1: NOP;

	AR = AR - 0x1;
	IF NE JUMP DelayMls;

{ спокойненько выходим из функции													}
	RTS;
{ =====================================================================	}
