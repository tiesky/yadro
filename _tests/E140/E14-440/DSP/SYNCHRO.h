{ ---------------------------------------------------------------------	}
{ В данном файле находятся функции запуска синхронизации, а именно:		}
{ - цифровой синхронизации старта или покадровой                    		}
{ - аналоговой синхронизации по уровню или переходу							}
{ ---------------------------------------------------------------------	}

{ *********************************************************************	}
{ Установка типа синхронизации														}
{ *********************************************************************	}
Synchronization:
	GetPm(AR, InputModeAddr);		{ проверим тип синхронизации				}

	AR = AR - 0x1;
	IF EQ JUMP TtlSynchroStart;	{ если 1, то цифровая 						}
											{						синхронизация старта	}
	AR = AR - 0x1;
	IF EQ JUMP TtlSynchroKadr;		{ если 2, то покадровая        			}
											{ 					цифровая синхронизация	}
	AR = AR - 0x1;
	IF EQ JUMP AdcSynchroStart;	{ если 3, то синхронизация 				}
											{								по каналу АЦП	}
	JUMP ErrorEndOfCommand;			{ выйдем с ошибкой в команде				}

{ *********************************************************************	}
{ цифровая синхронизация старта														}
{ *********************************************************************	}
TtlSynchroStart:
{ проинициализируем необходимые указатели и переменные						}
/*	CALL InitAdcPointers;*/
{ установим первой канал для работы АЦП											}
	CALL SetAdcFirstChannel;
{ задержка на установление аналогового тракта									}
	CALL SettlingDelay;

{ разрешим прерывания IRQE(команда) и IRQ1(внешняя синхронизация)			}
	GetPm(AR, ImaskValueAddr);
	AR = SETBIT 2 OF AR;				{ разрешим прерывания IRQ1					}
	PutPm(AR, ImaskValueAddr);
	
{ очистим запросы, кроме IRQE(команды) и SPORT0 Transmit (ЦАП)				}
	IFC = 0xAF; NOP;

{ теперь можно установить требуемую маску прерываний							}
	IMASK = AR;

{ штатное завершение выполнения команды											}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ покадровая цифровая синхронизация													}
{ *********************************************************************	}
TtlSynchroKadr:
{ проинициализируем необходимые указатели и переменные						}
/*	CALL InitAdcPointers;*/
{ установим первый канал для работы АЦП											}
	CALL SetAdcFirstChannel;
{ задержка на установление аналогового тракта									}
	CALL SettlingDelay;

{ теперь по месту метки Irq2Lab0 надо прописать код AF = AF - 0x1			}
	I4 = ^Irq2Lab0; AR = 0x2710; PX = 0x0F; PM(I4, M4) = AR;

{ а по месту метки Irq2Lab1 надо прописать код JUMP EnableSynchroPulse	}
	I4 = ^Irq2Lab1; AR = ^EnableSynchroPulse; CALL ModifyJump;

	ENA SEC_REG;						{ перейдем на второй банк регистров		}
		GetPm(AX0, ControlTableLenghtAddr);	{ AX0 - кол-во активных каналов 	}
		AF= PASS AX0;								{ AF - текущий счетчик прерываний}
	DIS SEC_REG;					  	{ перейдем на первый банк регистров		}

{ разрешим прерывания IRQ2(команда) и IRQ1(внешняя синхронизация)			}
	GetPm(AR, ImaskValueAddr);
	AR = SETBIT 2 OF AR;				{ разрешим прерывания IRQ1					}
	PutPm(AR, ImaskValueAddr);
	
{ очистим запросы, кроме IRQE(команды) и SPORT0 Transmit (ЦАП)				}
	IFC = 0xAF; NOP;

{ теперь можно установить требуемую маску прерываний							}
	IMASK = AR;

{ штатное завершение выполнения команды											}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ синхронизация по аналоговому каналу АЦП											}
{ *********************************************************************	}
AdcSynchroStart:
{ проинициализируем необходимые указатели и переменные						}
/*	CALL InitAdcPointers;*/
{ установим синхроканал	аналоговой синхронизации								}
	GetPm(AR, SynchroAdChannelAddr); PutPm(AR, AdcChannelAddr); CALL SetAdcChannel;
{ задержка на установление аналогового тракта									}
	CALL SettlingDelay;

{ установим максимальную частоту запуска АЦП равную 400.0 кГц	 			}
{												для опроса аналогового синхроканала	}
	AR = 59;
	DM(Sport1_Sclkdiv) = AR;		{ 0x3FF1 - Serial Clock Divide Modulus	}
	
{ установим новый обработчик прерываний IRQ2	 									}
{									специально однократного ввода данных с АЦП	}
	I7 = ^Irq2AdcSample;

{ а по месту метки MainLoop надо прописать код CALL AdSynchroIdle0		}
	I4 = ^MainLoop; AR = ^AdSynchroIdle0; CALL ModifyCall;

{ первый шаг аналоговой синхронизации												}
	PutValPm(AR, 0x0, SynchroAdStepAddr);

{ сбросим флажок-признак наличия необработанного прерывания от АЦП		}
	SI = 0x0;

{ определим какой канал будет корректируемый										}	
	GetPm(AR, AdcChannelAddr); PutPm(AR, CorrectableAdcChannelAddr);
{ положим в регистры в AY0 и MY1 корректировочные коэф. коррек. канала	}
	CALL GetCalibrCoef;

{ очистим запросы, кроме IRQE(команды) и SPORT0 Transmit (ЦАП)				}
	IFC = 0xAF; NOP;

{ разрешим прерывания IRQE(команда)													}
	GetPm(AR, ImaskValueAddr);
	AR = SETBIT 9 OF AR;				{ разрешим прерывания  IRQ2(АЦП)			}
	PutPm(AR, ImaskValueAddr);
	IMASK = AR; NOP;

{ разрешим АЦП включив клоки, т.е. сделаем SCLK1 внутренним					}
	AR = 0x7F1F;						{ 0111 1101 1100 1111						}
	DM(Sport1_Ctrl_Reg) = AR;		{ 0x3FF2 - SPORT1 Control Register		}

{ штатное завершение выполнения команды											}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ Обработчик прерываний IRQ2 для однократного ввода данных АЦП				}
{ *********************************************************************	}
Irq2AdcSample:
{ перейдем на второй банк регистров													}
	ENA SEC_REG;

{ считаем значение с текущего канала АЦП											}
	AR = IO(READ_ADC);
{ корректировка смещения																}
	AR = AR + AY1;
{ корректировка масштаба																}
	MR = AR * MY1(SU);
{ округление результата																	}
	MR = MR(RND);
{ положим скорректированный отсчёт с АЦП во временную переменную			}
	Dm(TempAdcSample) = MR1;
	
{ перейдем на первый банк регистров													}
	DIS SEC_REG; 						
	
{ установим флажок-признак, что есть необработанное прерывание от АЦП	}
	SI = 0x1;

{ выходим из обработчика прерывания													}
	RTI;

{ *********************************************************************	}
{ пропускаем первый отсчет АЦП - он левый											}
{ *********************************************************************	}
AdSynchroIdle0:
{ проверим наличие готового отсчёта с АЦП											}
	AR = SI; NONE = PASS AR; IF EQ RTS;

{ теперь по месту метки MainLoop надо прописать код CALL AdSynchroIdle1	}
	I4 = ^MainLoop; AR = ^AdSynchroIdle1; CALL ModifyCall;
{ сбросим признак наличия отсчёта с АЦП											}
	SI = 0x0;
{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ а остальные то, что надо																}
{ *********************************************************************	}
AdSynchroIdle1:
{ проверим наличие готового отсчёта с АЦП											}
	AR = SI; NONE = PASS AR; IF EQ RTS;

{ переложим скорректированное значение отсчёта с АЦП в регистр AR			}
	AR = Dm(TempAdcSample);
{ теперь займёмся проверкой условий синхронизации 								}
	GetPm(AY0, SynchroAdTypeAddr);		{ по уровню или переходу			}
	NONE = PASS AY0;
	IF NE JUMP StepSynchro;

LastAdSynchro:
	GetPm(AY0, SynchroAdPorogAddr); 		{ порог аналоговой синхронизации	}
	AF = AR - AY0;
	GetPm(AR, SynchroAdModeAddr);
	NONE = PASS AR;
	IF EQ AF = -AF;
	AF = PASS AF;
	IF LT JUMP SynchroAdDetected;
	RTS;

StepSynchro:
	GetPm(AY0, SynchroAdStepAddr);
	NONE = PASS AY0;
	IF NE JUMP LastAdSynchro;
	GetPm(AY0, SynchroAdPorogAddr);
	AF = AR - AY0;
	GetPm(AR, SynchroAdModeAddr);
	NONE = PASS AR;
	IF NE AF = -AF;
	AF = PASS AF;
	IF GE RTS;
	PutValPm(AR, 0x1, SynchroAdStepAddr);
	RTS;

SynchroAdDetected:
{ остановим АЦП выключив клоки, т.е. сделаем SCLK1 внешним					}
	AR = 0x3F1F; 						{ 0011 1111 0001 1111 						}
	DM(Sport1_Ctrl_Reg) = AR;		{ 0x3FF2 - SPORT1 Control Register		}

{ замаскируем все прерывания															}
	IMASK = 0x0; NOP;

{ задержка на 2 мкс для окончание оцифровки, так как в этот момент 		}
{								нельзя писать в выходной регистр номера канала	}
	CALL Delay2mks;
	
{ установим первой канал для работы АЦП											}
	CALL SetAdcFirstChannel;
{ задержка на установление аналогового тракта									}
	CALL SettlingDelay;

{ установим требуемую частоту запуска АЦП											}
	GetPm(AR, AdcRateAddr);
	DM(Sport1_Sclkdiv) = AR;		{ 0x3FF1 - Serial Clock Divide Modulus	}
	
{ восстановим старый обработчик прерываний IRQ2 								}
	I7 = ^GetAdData;
{ наконец по месту метки MainLoop надо прописать код CALL PutAcdData		}
	I4 = ^MainLoop; AR = ^PutAcdData; CALL ModifyCall;

{ установим флажок, что разрешена работа АЦП										}
	PutValPm(AR, 0x1, AdcEnableAddr);

{ очистим запросы, кроме IRQE(команды) и SPORT0 Transmit (ЦАП)				}
	IFC = 0xAF; NOP;

{ разрешим прерывания IRQE(команда)													}
	GetPm(AR, ImaskValueAddr);
	AR = SETBIT 9 OF AR;				{ разрешим прерывания IRQ2(АЦП)			}
	PutPm(AR, ImaskValueAddr);
	IMASK = AR; NOP;

{ запустим АЦП, включив клоки SCLK , т.е. сделаем их внутренним			}
	AR = 0x7F1F; 						{ 0111 1111 0001 1111 						}
	DM(Sport1_Ctrl_Reg) = AR; 		{ 0x3FF2 - SPORT1 Control Register		}

{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ Записать в PM по заданному адресу команду JUMP xxx			    			}
{ Вход:                                                     	  			}
{      I4 - адрес, куда записывается команда             					}
{      AR - адрес перехода xxx														}
{ *********************************************************************	}
ModifyJump:
{ запрещаем все прерывания																}
/*	DIS INTS;*/

{ Формируем код команды 																}
	SR1=0x0018;								{ 00000000 00011000 										}
	SR0=0x000F;								{ 00000000 00001111 						}
	SR=SR OR LSHIFT AR BY 4(LO);
	PX=SR0;									{ Получили 8 младших бит 				}
	AR=SR1;
	SR=LSHIFT SR0 BY -8(LO);
	SR=SR OR LSHIFT AR BY -8(HI);		{ Получили старшие 16 бит 				}
	M4=0x0;
	PM(I4, M4)=SR0;						{ Сохранили все 24-битовое слово 	}

{ разрешаем все прерывания																}
/*	ENA INTS;*/

{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ Записать в PM по заданному адресу команду CALL xxx			    			}
{ Вход:                                                     	  			}
{      I4 - адрес, куда записывается команда             					}
{      AR - адрес перехода xxx														}
{ *********************************************************************	}
ModifyCall:
{ запрещаем все прерывания																}
/*	DIS INTS;*/

{ Формируем код команды 																}
	SR1=0x001C;								{ 00000000 00011100 						}
	SR0=0x000F;								{ 00000000 00001111 						}
	SR=SR OR LSHIFT AR BY 4(LO);
	PX=SR0;									{ Получили 8 младших бит 				}
	AR=SR1;
	SR=LSHIFT SR0 BY -8(LO);
	SR=SR OR LSHIFT AR BY -8(HI);		{ Получили старшие 16 бит 				}
	M4=0x0;
	PM(I4, M4)=SR0;						{ Сохранили все 24-битовое слово 	}

{ разрешаем все прерывания																}
/*	ENA INTS;*/

{ спокойно выходим из функции															}
	RTS;
