{ ---------------------------------------------------------------------	}
{	Функции для работы с АЦП															}
{ ---------------------------------------------------------------------	}
{ *********************************************************************	}
{ Получение данных с АЦП																}
{ *********************************************************************	}
GetAdData:
{ перейдем на второй банк регистров													}
	ENA SEC_REG;

{ установка следующего канала АЦП													}
	AR = PM(I5, M5); IO(SET_ADC_CHANNEL) = AR;

{ чтение данных с АЦП																	}
	AR = IO(READ_ADC);
	AR = AR + AY1, AY1 = PM(I6, M6);
	MR = AR * MY1(SU), MY1 = PM(I6, M6);
	MR = MR(RND); DM(I3, M3) = MR1;
	M3 = 0x1;

{ если нужно, то декрементируем счетчик отсчетов в кадре, иначе RTI		}
Irq2Lab0:
	AF = AF - 0x1;
	IF NE RTI;

{ для межкадровой задержки в AF кол-во клоков межкадровой задержки,		}
{ 				а для покадровой синхронизации код JUMP EnableSynchroPulse	}
Irq2Lab1:
	AF = PASS AX1;

{ указатель I7 на обработчик прерываний для межкадровой задержки			}
	I7 = ^InterKadrDelayIrq2;
{ указатель I5 на начало управляющей таблицы 									}
	I5 = ^ControlTable;
{ перезапишем первый канал																}
	AR = PM(I5, M5); IO(SET_ADC_CHANNEL) = AR;
{ }
	M6 = 0x0;
{ выходим из обработчика прерываний													}
	RTI;

{ *********************************************************************	}
{ Обработчик прерываний IRQ2 для межкадровой задержки							}
{ *********************************************************************	}
InterKadrDelayIrq2:
{ перейдем на второй банк регистров													}
	ENA SEC_REG;

{ чтение данных с АЦП																	}
	AR = IO(READ_ADC);
	AR = AR + AY1, AY1 = PM(I6,M6);
	MR = AR*MY1(SU), MY1 = PM(I6,M6);
	MR = MR(RND);
	DM(I3, M3) = MR1;
	M3 = 0x0;

{ посчитаем кол-во клоков нужных для межкадровой задержки					}
	AF = AF - 0x1;
	IF NE RTI; 			{ если еще не все, то просто выйдем из прерывания	}

{ запись второго канала																	}
	AR = PM(I5, M5); IO(SET_ADC_CHANNEL) = AR;
{ AF - кол-во каналов в кадре															}
	AF = PASS AX0;
{ }
	M6 = 0x1;
{ восстановим стандартный обработчик прерываний IRQ2(АЦП)					}
	I7 = ^GetAdData;
{ выходим из обработчика прерываний													}
	RTI;

{ *********************************************************************	}
{ Разрешим IRQ1 для импульса по-кадровой синхронизации						}
{ *********************************************************************	}
EnableSynchroPulse:
{ Остановим АЦП, выключив клоки SCLK , т.е. сделаем их внешним				}
	AR = 0x3F1F; 						{ 0011 1111 0001 1111 						}
	DM(Sport1_Ctrl_Reg) = AR;		{ 0x3FF2 - SPORT1 Control Register		}

/*
!!!!!!!!!
сделать разные функции для внутренних и внешних клоков АЦП
!!!!!!!!!
*/

{ сохраним регистр I4																	}
	AY0 = I4;

{ разрешим прерывания IRQE(команда) и IRQ1(внешняя синхронизация)			}
	GetPm(AR,ImaskValueAddr);
	AR= SETBIT 2 OF AR;				{ разрешим прерывания IRQ1(внеш.синхр.)}
	AR= CLRBIT 9 OF AR;				{ запретим прерывания IRQ2(АЦП)			}
	PutPm(AR,ImaskValueAddr);

{ в регистре AF должен находиться текущий счетчик прерываний				}
	AF = PASS AX0;

{ восстановим регистр I4																}
	I4 = AY0;

{ временно запретим все прерывания													}
	DIS INTS;

{ положим в стэк регистр IMASK с новым значением								}
	POP STS;
	ENA SEC_REG;						{ перейдем на второй банк регистров		}
	IMASK = AR;
	DIS SEC_REG; 						{ перейдем на первый банк регистров		}
	PUSH STS;
	
{ теперь замаскируем все прерывания													}
	IMASK = 0x0; NOP;
{ разрешим все размаскированные прерывания										}
	ENA INTS;

{ небольшая задержечка																	}
	CNTR = 43; DO ConvertLoop UNTIL CE; ConvertLoop: NOP;
/*
cntr=20; do ConvertLoop UNTIL CE; ConvertLoop: NOP;
ena sec_reg;
ar=dm(Test0); ar=clrbit 0 of ar; dm(Test0)=ar; io(ttl_out) = ar;
  */
{ очистим запросы, кроме IRQE(команды) и SPORT0 Transmit (ЦАП)				}
	IFC = 0xAF; NOP;
	
{ выходим из обработчика прерываний													}
	RTI;

{ *********************************************************************	}
{ Команда запуска работы АЦП															}
{ *********************************************************************	}
Start_Adc_cmd:
{ остановим сбор данных с АЦП															}
	CALL StopAdc;

{ по месту метки MainLoop пропишем код CALL PutAcdData						}
	I4 = ^MainLoop; AR = ^PutAcdData; CALL ModifyCall;

{ сбросим флаг работы АЦП																}
	PutValPm(AR, 0x0, AdcEnableAddr);

{ установим частоту запуска АЦП														}
	GetPm(AR, AdcRateAddr);
	DM(Sport1_Sclkdiv) = AR;		{ 0x3FF1 - Serial Clock Divide Modulus	}

{ проинициализируем необходимые указатели и переменные АЦП					}
	CALL InitAdcPointers;

{ проверим тип ввода данных с АЦП													}
	GetPm(AR, InputModeAddr); NONE = PASS AR;
	IF NE JUMP Synchronization;	{ если есть синхр., то прыгаем на нее	}

{ установим первый и подготовим второй канал для работы АЦП					}
	CALL SetAdcFirstChannel;
{ задержка на установление аналогового тракта									}
	CALL SettlingDelay;
	
{ установим флаг работы АЦП															}
	PutValPm(AR, 0x1, AdcEnableAddr);

{ размаскируем прерывания IRQE(команда)				)							}
	GetPm(AR,ImaskValueAddr);
	AR = SETBIT 9 OF AR;				{ размаскируем прерывания IRQ2(АЦП)		}
	PutPm(AR,ImaskValueAddr);
	IMASK = AR; NOP;

{ установим источник импульсов запуска АЦП										}	
	CALL SetAdcClockSource;
{ запустим АЦП, включив клоки SCLK , т.е. сделаем их внутренним			}
	AR = 0x7F1F; 						{ 0111 1111 0001 1111 						}
	DM(Sport1_Ctrl_Reg) = AR; 		{ 0x3FF2 - SPORT1 Control Register		}

{ штатное завершение выполнения команды											}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ Команда останова работы АЦП															}
{ *********************************************************************	}
Stop_Adc_cmd:
{ остановим сбор данных с АЦП															}
	CALL StopAdc;

{ штатное завершение выполнения команды											}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ Функция останова работы АЦП															}
{ *********************************************************************	}
StopAdc:
{ временно запретим все прерывания													}
	DIS INTS;							
	
{ Остановим АЦП, выключив клоки SCLK , т.е. сделаем их внешним				}
	AR = 0x3F1F; 						{ 0011 1111 0001 1111 						}
	DM(Sport1_Ctrl_Reg) = AR;		{ 0x3FF2 - SPORT1 Control Register		}
	
{ сбросимим источник импульсов запуска АЦП										}	
	CALL ClearAdcClockSource;

{ размаскируем прерывание IRQE(команда)											}
	GetPm(AR,ImaskValueAddr);
	AR = CLRBIT 2 OF AR;			{ замаскируем прерывания IRQ1(внеш.синхр.)}
	AR = CLRBIT 9 OF AR;			{ замаскируем прерывания IRQ2(АЦП)			}
	PutPm(AR,ImaskValueAddr);
	IMASK = AR; NOP;

{ разрешим все размаскированные прерывания										}
	ENA INTS;							

{ сбросим флаг работы АЦП																}
	PutValPm(AR, 0x0, AdcEnableAddr);
	
{ задержка на 2 мкс для окончание оцифровки, так как в этот момент 		}
{								нельзя писать в выходной регистр номера канала	}
	CALL Delay2mks;

{ очистим запросы, кроме IRQE(команды) и SPORT0 Transmit (ЦАП)				}
	IFC = 0xAF;

{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ Команда получения кадра отсчетов с АЦП (если возможно)						}
{ *********************************************************************	}
Adc_Kadr_cmd:
{ а работа АЦП разрешена?																}
	GetPm(AR, AdcEnableAddr); NONE= PASS AR;
	IF NE JUMP EndOfCommand; 	{ никакого приема АЦП нет - просто выйдем	}

{ остановим сбор данных с АЦП															}
	CALL StopAdc;

{ а по месту метки MainLoop надо прописать код CALL GetAcdKadr				}
	I4 = ^MainLoop; AR = ^GetAcdKadr; CALL ModifyCall;

{ установим частоту запуска АЦП														}
	GetPm(AR, AdcRateAddr);
	DM(Sport1_Sclkdiv) = AR;		{ 0x3FF1 - Serial Clock Divide Modulus	}

{ проинициализируем необходимые указатели и переменные АЦП					}
	CALL InitAdcPointers;
{ установим первой канал для работы АЦП											}
	CALL SetAdcFirstChannel;
{ задержка на установление аналогового тракта									}
	CALL SettlingDelay;

{ размаскируем прерывания IRQE(команда) и IRQ2(АЦП)							}
	GetPm(AR,ImaskValueAddr);
	AR = SETBIT 9 OF AR;				{ размаскируем прерывания IRQ2(АЦП)		}
	PutPm(AR,ImaskValueAddr);
	IMASK = AR; NOP;

{ запустим АЦП, включив клоки SCLK , т.е. сделаем их внутренним			}
	AR = 0x7F1F; 						{ 0111 1111 0001 1111 						}
	DM(Sport1_Ctrl_Reg) = AR; 		{ 0x3FF2 - SPORT1 Control Register		}

{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ Функция сбора одного кадра отсчетов с АЦП										}
{ *********************************************************************	}
GetAcdKadr:
{ а не готовы ли уже данные кадра отсчетов с АЦП?								}
	AR = I3;									{ получим 'голову' FIFO АЦП			}
	AY0 = I2;  								{ получим 'хвост' FIFO АЦП				}
	AR = AR - AY0;
	GetPm(AY0, CurAdcFifoLengthAddr);{ текущая длина FIFO буфера АЦП		}
	IF LT AR = AR + AY0;		{ теперь в AR истинная разница между I3 и I2	}
	GetPm(AY0, ControlTableLenghtAddr);	{ длина управляющей таблицы		}
	NONE = AR - AY0; 						{ сравним эти величины					}
	IF LT RTS;								{ если меньше, то выйдем				}

{ по месту метки MainLoop пропишем код CALL PutAcdData						}
	I4 = ^MainLoop; AR = ^PutAcdData; CALL ModifyCall;

	JUMP Stop_Adc_cmd;

{ *********************************************************************	}
{ Команда получения однократного отсчета с АЦП (если возможно)				}
{ *********************************************************************	}
Adc_Sample_cmd:
{ а работа АЦП разрешена?																}
	GetPm(AR, AdcEnableAddr); NONE= PASS AR;
	IF NE JUMP EndOfCommand; 	{ никакого приема АЦП нет - просто выйдем	}

{ остановим сбор данных с АЦП															}
	CALL StopAdc;

{ установим требуемый аналоговый канал для однократного ввода данных		}
	GetPm(AR, AdcSampleChannelAddr); PutPm(AR, AdcChannelAddr);	CALL SetAdcChannel;
{ задержка на установление сигнала в аналоговом тракте (с запасом)		}
	CNTR = 1000;
	DO SettlingDelayLoop0 UNTIL CE;
SettlingDelayLoop0: NOP;

{ установим новый обработчик прерываний IRQ2(АЦП)								}
{									специально однократного ввода данных с АЦП	}
	I7 = ^Irq2AdcSample;

{ а по месту метки MainLoop надо прописать код CALL AdcSampleIdle0		}
	I4 = ^MainLoop; AR = ^AdcSampleIdle0; CALL ModifyCall;

{ установим максимальную частоту запуска АЦП равную 400кГц					}
	AR = 59;
	DM(Sport1_Sclkdiv) = AR;		{ 0x3FF1 - Serial Clock Divide Modulus	}

{ сбросим флажок-признак наличия необработанного прерывания от АЦП		}
	SI = 0x0;

{ определим какой канал будет корректируемый										}	
	GetPm(AR, AdcChannelAddr); PutPm(AR, CorrectableAdcChannelAddr);
{ положим в регистры в AY1 и MY1 корректировочные коэф. коррек. канала	}
	CALL GetCalibrCoef;

{ разрешим прерывания IRQE(команда) и IRQ2(АЦП)									}
	GetPm(AR, ImaskValueAddr);
	AR = SETBIT 9 OF AR;				{ разрешим прерывания IRQ2(АЦП)			}
	PutPm(AR, ImaskValueAddr);
	IMASK = AR; NOP;

{ разрешим АЦП включив клоки, т.е. сделаем SCLK1 внутренним					}
	AR = 0x7F1F;						{ 0111 1101 1100 1111						}
	DM(Sport1_Ctrl_Reg) = AR;		{ 0x3FF2 - SPORT1 Control Register		}

{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ пропускаем первый отсчет АЦП - он левый											}
{ *********************************************************************	}
AdcSampleIdle0:
{ проверим наличие готового отсчёта с АЦП											}
	AR = SI; NONE = PASS AR; IF EQ RTS;

{ теперь по месту метки MainLoop надо прописать код CALL AdcSampleIdle1	}
	I4 = ^MainLoop; AR = ^AdcSampleIdle1; CALL ModifyCall;
{ сбросим признак наличия отсчёта с АЦП											}
	SI = 0x0;
{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ а следующий то, что надо																}
{ *********************************************************************	}
AdcSampleIdle1:
{ проверим наличие готового отсчёта с АЦП											}
	AR = SI; NONE = PASS AR; IF EQ RTS;

{ в TempAdcSample находится скорректированный код с требуемого канала АЦП}
	AR = DM(TempAdcSample); PutPm(AR, AdcSampleAddr);

{ Остановим АЦП, выключив клоки SCLK , т.е. сделаем их внешним				}
	AR = 0x3F1F; 						{ 0011 1111 0001 1111 						}
	DM(Sport1_Ctrl_Reg) = AR;		{ 0x3FF2 - SPORT1 Control Register		}

{ размаскируем прерывание IRQE(команда)											}
	GetPm(AR,ImaskValueAddr);
	AR = CLRBIT 2 OF AR;			{ замаскируем прерывания IRQ1(внеш.синхр.)}
	AR = CLRBIT 9 OF AR;			{ замаскируем прерывания IRQ2(АЦП)			}
	PutPm(AR,ImaskValueAddr);
	IMASK = AR; NOP;

{ восстановим стандартный обработчик прерываний IRQ2(АЦП)					}
	I7 = ^GetAdData;
{ по месту метки MainLoop необходимо прописать код CALL PutAcdData		}
	I4 = ^MainLoop; AR = ^PutAcdData; CALL ModifyCall;
{ штатное завершение выполнения команды											}
	JUMP EndOfCommand;

{ *********************************************************************	}
{ запись логического канала в промежуточный и выходной регитр каналов	}
{ *********************************************************************	}
SetAdcChannel:
{ зададим логические каналы для следующих двух отсчетов						}
{ PF5 в ноль - запись в промежуточный регистр каналов							}
	AR=DM(Prog_Flag_Data); AR=CLRBIT 5 OF AR; DM(Prog_Flag_Data)=AR;

{ запись логического канала в промежуточный регистр каналов					}
	GetPm(AR, AdcChannelAddr); IO(SET_ADC_CHANNEL) = AR;

{ PF5 в единицу - перезапись в выходной регистр каналов						}
	AR=DM(Prog_Flag_Data); AR=SETBIT 5 OF AR; DM(Prog_Flag_Data)=AR;
{ PF5 в ноль - запись в промежуточный регистр каналов							}
	AR=DM(Prog_Flag_Data); AR=CLRBIT 5 OF AR; DM(Prog_Flag_Data)=AR;

{ запись логического канала в промежуточный регистр каналов					}
	GetPm(AR, AdcChannelAddr); IO(SET_ADC_CHANNEL) = AR;
{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ определимся с корректировочными коэффициентами								}
{ *********************************************************************	}
GetCalibrCoef:
{ умолчательные корректировочные коэф. смещения и усиления для АЦП		}
	AR = 0x0000; DM(TempArray + 0) = AR;
	AR = 0x8000; DM(TempArray + 1) = AR;

{ разрешена ли корректировка входных данных										}
	GetPm(AR, IsCorrectionEnabledAddr); NONE = PASS AR; IF EQ JUMP SetCorrectionCoefs;

{ параметры работы указателя I4														}
	M4 = 0x0; L4 = 0x0;

{ узнаем индекс усиления для используемого канала АЦП							}
	GetPm(AR, CorrectableAdcChannelAddr); SR = LSHIFT AR BY -6 (LO);
	M4 = SR0;

{ 	Set ZeroOffset																			}
	I4 = ^ZeroOffset; MODIFY(I4, M4);
	AR = PM(I4, M4); DM(TempArray + 0) = AR;

{ 	Set ScaleFactor																		}
	I4 = ^ScaleFactor; MODIFY(I4, M4);
	AR = PM(I4, M4); DM(TempArray + 1) = AR;

{ восстановим параметры работы указателя I4										}
	M4 = 0x0; L4 = 0x0;

{ окончательно разбираемся с корректировочными коэффициентами				}
SetCorrectionCoefs:
	ENA SEC_REG;						{ перейдем на второй банк регистров		}
		AY1 = DM(TempArray + 0);	{ AY1 - корр. коэффциент смещение АЦП	}
		MY1 = DM(TempArray + 1);	{ MY1 - корр. коэффциент масштаб АЦП	}
	DIS SEC_REG;					  	{ перейдем на первый банк регистров		}

{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ установим источник импульсов запуска АЦП										}	
{ *********************************************************************	}
SetAdcClockSource:
{ какой же именно источник тактовых импульсов запуска АЦП требуется?		}
	GetPm(AR, AdcClockSourceAddr); AR = AR - 0x1; AY0 = AR;

{ узнаем текущее состояние флагов PFx												}	
	AR = DM(Prog_Flag_Data); 
{ сбросим флаги PF2 и PF6, отвечающие за источник тактовых импульсов		}
{																				запуска АЦП	}	
	AR = SETBIT 2 OF AR; AR = CLRBIT 6 OF AR; 	{ внутренние клоки АЦП	}
	
{ сейчас можно попробовать определиться с заданным источником				}
{ тактовых импульсов запуска АЦП														}
	NONE = PASS AY0;	IF EQ AR = CLRBIT 2 OF AR;	{ внут. с трансляцией	}
/*	NONE = AY0 - 0x1;	IF EQ AR = CLRBIT 2 OF AR;*/
	NONE = AY0 - 0x1;	IF EQ AR = SETBIT 6 OF AR;	{ внешние клоки АЦП		}

{ теперь можно установить флаги PF2 и PF6 в соотвестсвии с					}
{									требуемым источником импульсов запуска АЦП	}
	DM(Prog_Flag_Data) = AR;

{ спокойно выходим из функции															}
	RTS;

{ *********************************************************************	}
{ сбросим источник импульсов запуска АЦП											}	
{ *********************************************************************	}
ClearAdcClockSource:
{ узнаем текущее состояние флагов PFx												}	
	AR = DM(Prog_Flag_Data); 
{ сбросим флаги PF2 и PF6, отвечающие за источник тактовых импульсов		}
{																				запуска АЦП	}	
	AR = SETBIT 2 OF AR; AR = CLRBIT 6 OF AR;
{ теперь можно установить флаги PF2 и PF6 										}
	DM(Prog_Flag_Data) = AR;

{ спокойно выходим из функции															}
	RTS;
